// This file was generated by lezer-generator. You probably shouldn't edit it.
import {LRParser} from "@lezer/lr"
export const parser = LRParser.deserialize({
  version: 14,
  states: "#lOVQPOOQhQQOOOVQPO'#CiOOQO'#Co'#CoOVQPO,58{OVQPO,58{OVQPO,58{OVQPO,58{OVQPO,58{OVQPO,59VO!SQQO,59TOOQO1G.g1G.gO!{QQO1G.gO#YQQO1G.gO#xQQO1G.gO$`QQO1G.gO$gQQO1G.qOOQO7+$R7+$ROVQPO7+$]O$nQQO<<Gw",
  stateData: "%U~ObOS~OQRORROSROYQO^QO~OUSOVTOWTOXTOYUOZVO[WOeXO~O`]ad]af]a~PhOUSOYTiZTi[Ti`TieTidTifTi~OVTiWTiXTi~P!aOVTOWTOXTO~P!aOUSOVTOWTOXTOYUO~OZTi[Ti`TieTidTifTi~P#gOdaO~PhOfbO~PhOZVOeXO[_y`_yd_yf_y~P#gO",
  goto: "!]dPPPPPePPPPPPPePePPPpcROQSTUVWXbQPOQYQQZSQ[TQ]UQ^VQ_WQ`XRcb",
  nodeNames: "âš  EvalProgram Identifier Number String BinaryExpression Map Inbuilt Inbuilt Inbuilt Inbuilt Inbuilt Filter UnaryExpression Inbuilt ConditionalExpression",
  maxTerm: 22,
  skippedNodes: [0],
  repeatNodeCount: 0,
  tokenData: "&[~RmX^!|pq!|qr#qrs$Ouv$mz{$r{|$w}!O$w!O!P$|!P!Q%R!Q![%W![!]%`!^!_%e!_!`#y!`!a%e!a!b%m!c!}%r!}#O&Q#P#Q&V#R#S%r#T#o%r#y#z!|$f$g!|#BY#BZ!|$IS$I_!|$I|$JO!|$JT$JU!|$KV$KW!|&FU&FV!|~#RYb~X^!|pq!|#y#z!|$f$g!|#BY#BZ!|$IS$I_!|$I|$JO!|$JT$JU!|$KV$KW!|&FU&FV!|R#vP^P!_!`#yQ$OOZQ~$RTOr$Ors$bs;'S$O;'S;=`$g<%lO$O~$gOS~~$jP;=`<%l$O~$rOW~~$wOX~~$|OY~~%ROU~~%WOV~~%]PR~!Q![%W~%eOf~Q%jPZQ!_!`#y~%rOe~~%wRQ~!c!}%r#R#S%r#T#o%r~&VO[~~&[Od~",
  tokenizers: [0, 1],
  topRules: {"EvalProgram":[0,1]},
  tokenPrec: 0
})
